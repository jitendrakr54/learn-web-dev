****************************************** Module Introduction *******************************************************
. Module Content:
            . Handling Events
            . Updating the UI & Working with "State"
            . A Closer look at components & State
        
***************************************** Listening to Events & working with Event Handlers *************************
. To handle events, let's add a button in ExpenseItem component and I wanna change the title which is being output here.
  Initially, the title which is being output is the title we get via props. But I wanna change it whenever this button is
  clicked. And therefore, we, of course, first of all, need to find out how exactly we can react to button clicks in 
  React. And it turns out that this is rather simple. On all built-in HTML elements, like divs and h2, and especially 
  all the buttons and so on, we have full access to all these native DOM events which we can listen to.

. And basically, for all these default events, there is a prop equivalent in React, which we can add to these built-in 
  HTML elements to listen to these events. So instead of adding a listener as we would normally do it, by for example 
  selecting an element by ID and then adding an event listener like this, which would be the imperative way of doing 
  that, in React, we add an event listener by going to the JSX element, like this button. And there we add a special 
  prop. But now it's not a prop which sets some value or this button, but instead it's a prop which starts with "on". 
  Because React exposes all these default events as props which start with on. And for example, here we can add onClick. 
  Now, what this does is it adds an event listener for click events to this button. Now we just need to define what 
  should happen when such a click occurs by defining handler function.

  eg:
    function ExpenseItem(props) {
        const clickHandler = () => {
            console.log("Clicked!!!");
        };

        return (
            <Card className="expense-item">
                <ExpenseDate date={props.date} />
                <div className="expense-item__description">
                    <h2>{props.title}</h2>
                    <div className="expense-item__price">${props.amount}</div>
                </div>
                <button onClick={clickHandler}>Change title</button>
            </Card>
        );
    }

. And that is how we can add event listeners to our elements. To all these built-in HTML elements, we can add supported 
  event listeners basically.

**************************************** How Component Functions are executed ******************************************
. Now we want to change title by clicking button so we can create a variable and initialize that with props.title and 
  then change it in handler function which is executed on click. 

  eg:
    function ExpenseItem(props) {
        let title = props.title;

        const clickHandler = () => {
            title = "Updated";
            console.log("Updated!!!");
        };

        return (
            <Card className="expense-item">
                <ExpenseDate date={props.date} />
                <div className="expense-item__description">
                    <h2>{title}</h2>
                    <div className="expense-item__price">${props.amount}</div>
                </div>
                <button onClick={clickHandler}>Change title</button>
            </Card>
        );
    }

. Because we are outputting title down there, we're changing it up on a click we should see that value here in this place
  after such a click happened. Well, let's save everything and give a try. If we go back, you'll notice that if I click 
  change title , nothing happens. This title here never changes, so why is this happening? Is something wrong with our 
  click handler? Well this function is getting triggered, as we can see in Clicked!!! in console.

. But title does not changes. simply because react doesn't work like this. And that's where now we have to dive into how 
  react actually passes the JSX code and how it considers that and how it brings it on to the screen. There's one key 
  thing which we have to keep in mind that your component is a function. This is a function right? Your component is 
  just a regular function, the only special thing about that function, is that it returns JSX. Now since it's a 
  function, someone has to call it, and you might notice that we never called our component functions, instead we just 
  used these functions like HTML elements in this JSX code. Well, the thing is, under the hood this is almost like a 
  function call. By using our components in JSX code, we make React aware of our component functions.

. For example here, we make react aware of the ExpenseItem function. And whenever react evaluates this JSX code, it will 
  call these component functions. And these component functions stand to return JSX code, which is all the evaluated, up 
  until there's no more JSX code to be evaluated. So in the case of Expenses.js, if React encounters this ExpenseItem, it
  calls this ExpenseItem component function, executes all the code in there, encounters this JSX code and calls this Card
  function and this Expense state function and then it goes through the JSX code of this components until there's no more
  component code left to call. And then it re-evaluates the overall result and translates that into DOM instructions which renders something like this on the screen. That's how react works.

. Now it's all started by the index.js file, where we initially point at this App component. That's the first component 
  function which is being called and that happens when the React App has been loaded on the screen which happens when the
  page is been visited. So that's how react goes through all these components executes all these components functions
  and draws something on to the screen. The only problem with that is, "that react never repeats that". React goes 
  through all of that when the application is initially rendered, but thereafter it's done.

  However in modern applications, of course you sometimes want to update what's visible on the screen, for example 
  because a button was clicked and that button should change some text which is being output. So we need a way of 
  telling react that something changed and that a certain component should be re-evaluated and that's where react 
  introduces a special concept called "State".

************************************************** Working with "State" ************************************************
. State is actually not a React specific concept but it is a key concept in React as well. And here in ExpenseItem, we 
  have a scenario where we wanna use that built-in state concept. Because this title here which changes when the 
  clickHandler executes is actually data that should result in this component being re-evaluated and re-drawn on the 
  screen when it's changes, when that's title data changes. And by default, regular variables like this one, are not 
  triggering such a re-evaluation.

. If you have a variable in your component function and the that variable changes, React ignores it. It doesn't care 
  about that, that code executes, sure, but the overall component function doesn't execute again just because some 
  variable changed. And as a side note, even if it would execute again, of course then title, this variable, would all 
  just be recreated and re-initialized to the props value. Because as part of this component function we are creating 
  this title variable.

********************************* useState():
. And we want to import a function here, a function which is called useState. This is a function provided by the React 
  library which allows us to define values as state where changes to these values should reflect in the component 
  function being called again, which is a key difference to the regular variable we're using here.

  Now, how do we use this useState function though? Inside of our component function and that's important, just call 
  useState. And useState is a so-called React hook. There are other hooks as well, And all these React hooks can be 
  recognized by the fact that they start with the word "use" in their name, and all these hooks must only be called
  inside of React component functions like ExpenseItem. They can't be called outside of these functions. And they all 
  just shouldn't be called in any nested functions. They must be called directly inside such component functions. 
  
  Now, useState doesn't work just like that. Instead, useState once a default state value, because with useState we 
  basically create a special kind of variable, you could say, a variable where changes will lead this component function 
  to be called again. And of course we can therefore assign an initial value for that special variable, So here, my 
  initial value is props.title. And we simply pass this as an argument to useState. Now does special variable is 
  created. Of course, we also want to be able to use that variable, we want to be able to use it down here, and 
  therefore useState also returns something. It gives us access to this special variable. However, it does not just 
  return that, it also returns a function which we can then call to assign a new value to that variable. So we'll not be 
  assigning values like this with the equal sign, instead, we will be assigning new values by calling a function. That's 
  just how this state variable thing works.

  function ExpenseItem(props) {
    const [title, setTitle] = useState(props.title);

    const clickHandler = () => {
        setTitle("Updated!");
        console.log(title);
    };

    return (
        <Card className="expense-item">
            <ExpenseDate date={props.date} />
            <div className="expense-item__description">
                <h2>{title}</h2>
                <div className="expense-item__price">${props.amount}</div>
            </div>
            <button onClick={clickHandler}>Change title</button>
        </Card>
    );
  }

  And for that useState actually returns an array where the first value is the variable itself, you could say, the value
  itself. And the second element in the array is that updating function. The first element, is a pointer at that managed
  value. So initially at props title (title), the value stored in props.title,and the second element here is a function 
  (setTitle) which we can later call to set a new title. And it's always the case that the first element is the current 
  state value. And the second element is a function for updating that. And thereafter we would want to assign new value 
  on button click which means we need to assign that value in handler. and we're not going to assign a new value with an 
  equal sign. Instead, we assign a new value by calling setTitle. So by calling this state updating function and then we 
  just passed a new value as argument, in this case updated.

***************************************** A Closer look at the "useState" Hook *****************************************
. UseState registers some State, so some value as a State for the component in which it is being called. And I wanna be 
  even more precise here. It registers it for a specific component instance. For example, ExpenseItem here is being used 
  four times, right? And Expenses.js we have four ExpenseItems. Now, every item receives its own separate State which is 
  detached from the other States. We have one ExpenseItem definition here, but then this function is basically called 
  four times when we create four ExpenseItems. And every time it's called, a new separate State is created of course in 
  the same way but managed independently by React. So if we change the title in the first ExpenseItem the other ones are 
  not affected because they have their own State. That's really important. It's on a per component instance basis. 
  because it would be a rather undesired behavior if we change something in one item and all the other items are updated 
  as well. So that's a good thing to have.

. So if we called setTitle and we assign a new title, that leads to this component being called again and therefore, this
  new title, this updated title is fetched from React, which manages the State for us. Basically we go to React and say, 
  "Hey please give me that latest title State which I told you to manage for me." And React provides us this latest State
   in this array which useState always returns. So we always get a brand new snapshot of that State when this component 
   function re-executes. That's how this works under the hood.

******************************************* State can be updated in many ways! *****************************************
. Thus far, we update our state upon user events (e.g. upon a click). That's very common but not required for state 
  updates! You can update states for whatever reason you may have. Later in the course, we'll see Http requests that 
  complete where we then want to update the state based on the Http response we got back) but you could also be updating 
  state because a timer (set with setTimeout()) expired for example.

****************************************** Adding form inputs *********************************************************
. Added NewExpense subfolder and created ExpenseForm and NewExpense component and used NewExpense in App component

****************************************** Listening to User Input ****************************************************
    <div className="new-expense__control">
        <label>Title</label>
        <input type="text" onChange={titleChangeHandler} />
    </div>

    const titleChangeHandler = (event) => {
        console.log(event.target.value);
    };

****************************************** Working with multiple states ************************************************
. The question now is what do we want to do with that value? What's the goal now? And the answer is, well, we want to 
  make sure that we store it somewhere so that when later when the form is submitted, we can use that value. Because of 
  course, we want to gather all the values for all inputs and then combine them into an object when the form overall is 
  submitted.

. And one way of storing that value and making sure that it survives, even if that function would be re executed for 
  whatever reason, we can again, use State.

. How can you manage more than one State?
  It is something we have learned up to this point but it turns out that it is rather simple. You can call useState more 
  than once. You can have multiple States, multiple States slices or State pieces per component. And all of these States 
  inside of one at the same component will then all to be totally separated from each other. 
  eg:
    const [enteredTitle, setEnteredTitle] = useState("");
    const [enteredAmount, setEnteredAmount] = useState("");
    const [enteredDate, setEnteredDate] = useState("");

***************************************** Using One State InStead (And what's Better) **********************************
. We can have one state instead as all three states are related to user input, by calling useState only once and by 
  passing in an object as a value and that's important not a string or number or anything like that, but an object. And 
  of course in this object, you can now group together, your three States.
  eg:
    const [userInput, setUserInput] = useState({
        enteredTitle: "",
        enteredAmount: "",
        enteredDate: "",
    });

. The difference now, of course is that whenever you update this state you need to update all three properties and not 
  just one where you also ensure that the other two pieces of data don't get lost. So if you are updating the title, you 
  also want to copy in the existing values for amount and date. And one way of doing this would be to use the spread 
  operator which is a default JavaScript operator in modern JavaScript.
  eg:
    const titleChangeHandler = (event) => {
        setUserInput({
            ...userInput,
            enteredTitle: event.target.value,
        });
    };

. Generally, you can switch between these approaches. Now, I tend to prefer the individual state slices, And I would say 
  you also see that more often out there in the world, in other react projects, but ultimately both approaches are fine.

********************************** Updating State that depends on the previous state ************************************
. Now the way I'm updating my state here is not entirely correct though. It technically would work, but in niche cases it
  could fail, and it's simply not a good practice to update it like this. So what's the problem here? 
  Here, I'm depending on my previous state for updating the state. In this case, we depend on the previous state because
  we used this one state instead of three-states approach and we need to copy in the other values so that we don't lose 
  them. Hence we depend on the previous state snapshot to copy in the existing values and then just override one value 
  with a new one.

. Now whenever you update state and you depend on the previous state, you should not do it like this but you should use 
  an alternative form of this state updating function. Instead of calling it like this, you should call it and pass in a 
  function to that function. So you call the setUserInput function and you pass a function to it, for example, such an 
  anonymous arrow function. And this function, which you pass to setUserInput here, will automatically be executed by 
  React. And it will receive the previous state snapshot for that state for which you're calling the updating function.
  eg:
     const titleChangeHandler = (event) => {
        setUserInput((prevState) => {
            return { ...prevState, enteredTitle: event.target.value };
        });
    };

. Now why should we do it like this instead of like this? In many cases, both will work fine, but keep in mind that I 
  mentioned that Reacts schedules state updates, it doesn't perform them instantly. And therefore, theoretically, if you 
  schedule a lot of state updates at the same time, you could be depending on an outdated or incorrect state snapshot if 
  you use this approach. If you use this approach, React will guarantee that the state snapshot it gives you here in this
  inner function, will always be the latest state snapshot, keeping all scheduled state updates in mind. So this is the 
  safer way to ensure that you always operate on the latest state snapshot.

********************************************* Handling form submission *************************************************
. Added submit handler which combines all expense data in an object.
    const submitHandler = (event) => {
        event.preventDefault();

        const expenseData = {
            title: enteredTitle,
            amount: enteredAmount,
            date: new Date(enteredDate),
        };
        console.log(expenseData);
    };

    <form onSubmit={submitHandler}>

********************************************* Adding two-way binding ***************************************************
. We can now implement something which is called two-way binding, which simply means that for inputs we don't just listen
  to changes, but we can also pass a new value back into the input. So that we can reset or change the input 
  programmatically. And how do we do that? Well, it's very simple. All we have to do is add the value attribute, which is
  a default attribute, to this input element. This will set the internal value property, which every input element has.
  And we can set it to a new value. And here, I will bind this to enteredTitle. So now it is this two-way binding, because now we don't just listen to changes in the input to update our state. But we also feed the state back into the input so that when we change the state, we also change input.

. This might sound like an infinite loop, but it actually isn't. So we won't have a problem there. But the advantage is 
  that when the form is submitted for example, we can call setEnteredTitle. And set this back to an empty string, which 
  also was our initial state. And by doing that, we override what the user entered after the form was submitted and 
  therefore cleared the input.

******************************************* Child-to-parent component communication (Bottom-up)*************************
. We are able to gather our expense data, our user input and combine it into this object and clear the form thereafter.
  The only problem is that having this data is nice but we technically don't need it in the expense form component, do 
  we? Instead we needed in the NewExpense or to be precise in the App.js component even because there we have our 
  expenses array and ultimately our goal will be to add this new expense which the user entered to this list of existing 
  expenses and we probably also wanna enrich it by adding an ID. So, we need to pass the data which we're collecting and 
  generating in ExpenseForm to the app component. Now I put as point, we only learned how we can pass data down. So how 
  we can, for example, in the expenses folder pass title, amount and date from the ExpenseForm component to the 
  ExpenseItems component.

. We can create our own event props, and we can expect functions as values and that would allow us to pass a function 
  from a parent component to a child component and then call that function inside of the child component. And when we 
  then call a function, we can of course pass data to that function as a parameter and that's how we can communicate up 
  from child to parent.

  const NewExpense = () => {
    const saveExpenseDataHandler = (enteredExpenseData) => {
      const expenseData = {
        ...enteredExpenseData,
        id: Math.random().toString(),
      };
      console.log(expenseData);
    };

    return (
      <div className="new-expense">
        <ExpenseForm onSaveExpenseData={saveExpenseDataHandler} />
      </div>
    );
  };

  props.onSaveExpenseData(expenseData);

******************************************** Lifting the state up ******************************************************
. Consider this basic Component Tree (See pdf) which is roughly what we have in this demo application where we have an 
  App component which in turn renders expenses and a new expense component. Now, in this case, the NewExpense component 
  is a component which generates some data, some state. In our example application, we are fetching some user input here.
  Now it is quite common that you do generate or fetch data in a component but that you might not need that data in that 
  component. Instead, we need it in another component, in the expenses component. That's where this generated data is 
  needed in the end, slightly transformed, packed into an object but it is the data we fetch in new expense. So naturally
  we would like to hand that data over but that doesn't work like this because we have no direct connection between two 
  sibling components. Instead, as you learned by now, we can only communicate from parent to child and from child to 
  parent.

. That's why in such cases like we have it here, we utilize the closest component, the closest parent component which has
  direct or indirect access to both involved components in this case, the app component. The app component in our 
  application has access to both the NewExpense and the expenses component because it renders both components in its 
  returned JSX code, that's why we wanna utilize that. Because we can now store our state in that closest involved 
  component. So in that parent component which has access to both involved components by lifting our state up. So by 
  passing our generated state data from the new expense to the app component.

. We're doing this by utilizing props, by calling the function we receive on the onAddExpense prop. That alone is not 
  lifting the state up. That's just calling a function we receive through props. But then we do something important.
  We actually do pass data to that function which we call here. We pass the expense data to function we receive on the 
  onAddExpense prop. So we're passing data to that function, and by doing that we're lifting that data, that state up.

********************************************* Assignement 2***********************************************************
. Create ExpenseFilter component and use that in Expenses component


************************** Controlled vs Uncontrolled Component & Stateless vs Stateful Components ********************
. We created a controlled component and it's not the first time we did that. Basically, whenever you use two way binding
  you are controlling a component but here we're controlling our own custom component. Now, what does this mean?
  It means that a value which is used in the component like the value selected in the dropdown is passed on to a parent 
  component, through props and is received from the parent component. Both the currently set value, as well as the 
  function which in the end handles the selected value is not part of expenses filter. ExpensesFilter is really just a 
  component that presents GUI, that presents the dropdown and then attaches a couple of listeners or props, but the real 
  logic recides in the parent component and that turns ExpensesFilter into something which is called a controlled 
  component.

  Another term you should be aware of because you might hear it from time to time is about presentational verses stateful
  components or stateless versus stateful components or dumb versus smart components. There are a lot of terms for that, 
  but what do they mean? It simply means that in basically all React apps which you're building, you will have a couple 
  of components that manage some state like this Expenses component which manages this filter state or the ExpenseForm 
  component which manages the input state. And then you will have other components which don't manage any state, like 
  ExpenseItem. This component is a state less component also called presentational or dumb component because it doesn't 
  have any internal state it's just there to output some data. And in most react applications, you will have more 
  presentational and dumb components than smart or stateful components. So even though dumb might sound negative and it 
  might sound like stateful components are better, that's not the case. These are really just terms and typically you end
  up with less state full components than with state less components.