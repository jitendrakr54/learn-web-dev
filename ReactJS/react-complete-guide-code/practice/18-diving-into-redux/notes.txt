*************************************************** Module Introduction ************************************************
. A very popular third party React Library.
. Content :
    . What is Redux? And Why?
    . Redux Basics & Using redux with React

************************************************* Another look at state in react apps **********************************
. Refer pdf
. Redux is a state management system for a cross-component or app-wide state. So it helps us manage state, data that 
  changes and affects our application and what we display on the screen. It helps us manage such data across multiple 
  components or even the complete app.

. But we can split the definition of state into three main kinds of state -
  Local State, Cross-component State, App-wide State

. Local state is state so data which changes that affects the UI which belongs to a single component. And for example, 
  if we listen to a user input and we use useState to store that input with every keystroke in a state variable. And 
  typically we manage such local state inside of a component with useState or if it's more complex maybe with useReducer.

. Now we also often have state that affects not just one component but multiple components. That would be cross 
  component state. For example, if we have a button that opens or closes a modal overlay such a modal component might 
  affect multiple components and the trigger for opening the modal is per definition So then we have multiple components 
  working together to display and hide a modal. 
  
  And we can also implement that with useState or useReducer we then just need to pass props around so we need to build 
  those prop chains or do this prop drilling as it's also called where we pass props across multiple components where we 
  also might pass functions as props across multiple components so that these different components can work together and 
  manage state together. 

. Sometimes we also have State that does not just affect multiple components but basically all components of an 
  application. Now when that happens we could call this app-wide state and an example here would be user authentication.
  If I log in we might need to change the navigation bar because we now show new options and we also certainly affect a 
  lot of other components which now show more or less data. So that would be an example for app-wide state. And we can 
  also manage this with the useState, useReducer and then by passing state values and updating functions around full 
  props.

. Now for cross-component and app-wide state passing around data and updating function fruit props can become cumbersome
  though. And that's why we did learn about React Context. React Context is a built in feature in React that makes 
  managing cross-component or application wide state easier. So that's one way of simplifying cross-component and 
  app-wide state management.

. Redux solves the same problem. So both React Context and Redux are there to help us manage such cross-component or 
  app-wide States. And that of course brings up an important question. Why do we need Redux if we already have React 
  Context for managing state that affects multiple components?


************************************************** Redux vs React Context **********************************************
. React Context has a couple of potential disadvantages. And I say potential because they might not matter in the app 
  you're building. And if they don't matter, you don't need Redux. It is as simple as that. You can also use both 
  Contexts and Redux in the same application. Typically for application wide-state, you will only use one of the two,
  but then you could be using Redux for the general application wide-state and still use Context for selected 
  multi-component states which are important in parts of your application.

. But what are these disadvantages then? One potential disadvantage is that with React Context, you can have a very 
  complex setup and managing state with React Context can become quite complex. And that definitely depends on the kind 
  of application you're building. For a lot of small or medium-sized applications that will very likely not be a problem 
  But if you're building a large application an enterprise level application with a lot of components and a lot of 
  things going on, then when using React Context, you can end up with code like this Refer pdf Where you have a lot of
  different pieces of Context, a lot of different States that affect multiple components or the entire app, and therefore
  a lot of different Context Provider components which you built for managing these states. And you can end up with 
  deeply nested JSX code like this as a result. (Refer pdf)

  Of course you don't need to build a lot of different Context Providers though, you could just use one big Context and 
  one Context Provider component for a managing the entire state and all the different kinds of state of your 
  application. But that could lead in a large Context Provider component which manages a lot of different things, and 
  therefore itself becomes quite difficult to maintain and manage because it's doing a lot of things. You might end up 
  with a large Context that cares about authentication, theming, user input, if a modal should be displayed or not, and
  maybe a lot of other things as well. So, that could be a downside.

. Another potential disadvantage could be performance. We have an official quote by a member of their React team, who 
  basically says that the new Context, which is the Context you learn about in this course, the post is from 2018, 
  that this Context is great for low-frequency updates like changing a theme, or maybe also authentication,
  but it's not that great if your data changes a lot, for a high frequency changes.

  For changes that happen more frequently or often general that it's not that good for that. And this team member says 
  that, therefore this new context is not ready as a replacement for flux like state propagation.(Redux is a flux like 
  state management library). So he says that React Context is not really a great replacement for Redux in all scenarios, 
  in all cases. So therefore that's our second disadvantage, performance can be bad if you're managing the wrong kinds 
  of state with React Context.

. Now, therefore to sum it up, we have the complex setup and management disadvantage because we may end up with deeply 
  nested JSX code and a lot of different Context Providers or with one huge Context Provider which is not maintainable.
  On the other hand we have potential performance issues because we should not use React Context for high-frequency 
  state changes.

************************************************** How Redux works *****************************************************
. Refer pdf notes for pictoral representation

. Well, Redux is all about having one Central Data Store, in your application. And with data I mean state. You have 
  exactly one store. You never have more than one store. It's one store, for all your state for your entire application.
  So in this store, you would store authentication state theming, maybe some user input state you wanna save, whatever 
  it is. Whichever cross component or app wide state you have, it goes into this one store. Now this might sound 
  unmaintainable, but the good thing is that we don't directly need to manage, the entire store all the time. 
  
. So we have this Central Data Store. What do we do with it? Ultimately, we have data in that store, so that we can use 
  it from inside our components. Because if some data changes, if the authentication status of a user changes for 
  example, we wanna know about that in a component, so that we can react accordingly, and update the UI.

  For this components set up subscriptions, to our Central Store. They subscribe to the store, and whenever the data 
  changes, the store notifies components, and then components can get the data they need, for example the current 
  authentication status, so they get a slice of the Redux store, and they can then use it.

. But of course, since this is state, so data which also changes from time to time. We need a way of changing that data.
  So how do we change data into stored in? Here's one very important rule. Components, never directly manipulate the 
  store data.

  So we have that subscription, but we don't have a data flow in the other direction. At least not a direct data flow.
  Components don't directly manipulate that data in the store. Instead for that, we use a concept called reducers.
  We have a reducer function. This reducer function which we have to set up. This function is responsible, for mutating.
  So for changing the store data.

  Reducer functions in general, are just a general concept. Reducer functions are functions, which takes some input,
  and then transform that input, they reduce it, for example they can reduce a list of numbers to the sum of that number 
  and that's just one example. But they in general transform, inputs and spit out a new output a new result. So that's a 
  general programming concept,

. Okay so we have a reducer function, which is responsible for updating the store data. And we have components that 
  subscribe to that data. How do we now connect components and that reducer function? Because ultimately, it will of 
  course be the components that should trigger a data change. It is for example a click on a button in a component
  that should trigger some data change. So how do we connect that.

  Trigger is a good word for that. Because we have a third concept here. We have actions and components dispatch actions.
  And therefore we could also say that components trigger, certain actions. Now an action is really just a simple 
  JavaScript object, which describes the kind of operation, the reducers should perform. Therefore, Redux then forwards 
  actions to the reducer, reads that description of the desired operation, then this operation is performed by the 
  reducer.

  So components dispatch actions, which describe what should be done, but don't do it directly, then these actions are 
  forwarded to the reducer, the reducer then does what the action wants, the reducer to do. And then the reducer, spits 
  out a new state, which effectively will replace the existing state in that Central Data Store. And when that happens,
  when that state in that data store is updated, subscribing components are notified, so that they can update their UI.
  That's how Redux works.

************************************************* Exploring the core redux concepts *************************************
. create a folder and inside that folder run: npm init -y     ->      npm install redux

. Now we can create such a store by using that imported Redux object. And then on that object, we can call, createStore.
  That's a method exposed by the Redux library, which does what the name implies, it creates a store. What do we do with 
  that store? Well, that store should manage some data and the data which it manages is in the end determined by the 
  reducer function, because it's the reducer function which will produce new state snapshots.

  The reducer has to go of spitting out a new state snapshot whenever an action reaches it. And when we run this code 
  for the first time, the reducer will also be executed with a default action, A reducer function is a standard 
  JavaScript function, but it will it be called by the Redux library and it will then always receive two pieces of input,
  two parameters, the old or existing state and the action that was dispatched. And then this reducer function must 
  return a certain output. It must always return a new state object. And there should be no side effects inside of that 
  function. So you must not send a HTTP request or write something to local storage or fetch something from local 
  storage there. Instead, a reducer should really just be a function that takes the given inputs, which are provided by 
  Redux and then produces the expected output, a new state object. State can also just be a number or a string. But in 
  reality, it will most often be an object.


  Now we also need someone who subscribes to that store, and then we need an action that can be dispatched. So does 
  subscriber is a function here, which does not get any parameters, but where we then inside of the function can reach 
  out to the store and call, getState. getState is a method which is available on the store created with create store.
  And it will give us the latest state snapshot after it was updated. So this subscription function will soon be 
  triggered whenever the state changes. And then when it is triggered, we can get to that latest state after it was 
  changed with the getState method here.


  Now we just need to make Redux aware of this subscriber function and tell it that this function should be executed
  whenever our state changes. And we do that by reaching out to the store and calling the subscribe method on the store,
  another method which exists there. The subscribe method then wants such a subscriber function. So to subscribe method 
  expects a function which Redux will then execute for us whenever the data and the store changed. So here we now pass 
  the counter subscriber to subscribe.

  And then you can run node and then your file name, And if you do that, you should see an error. You will get an error
  that you cannot read property counter of undefined. Now this is an expected error and why are we getting it? Well, we 
  are creating a store here and that store has a counter reducer as it needs to, and in that reducer, we return a state 
  object, which sets the counter to the old state counter plus one. The problem is that when that store is initialized,

  Redux will execute this reducer for the first time. So this code will then run when the store is created. The problem 
  is that at this point of time, state is undefined. We have no existing state because it's the first time this is 
  executing. That's why we should give state this state parameter, a default value, which is assumed if it would 
  otherwise be undefined. So that for the first time this runs, it does have a value. If it then runs thereafter and we 
  do have an existing state, the default value will not be used, but here for the first time, we wanna have a fallback 
  default value which will be used. And here I'll set my default value to an object which has a counter property,
  which is zero initially.


  let's now create and dispatch an action. For this we again, use that store object and on that object besides get state 
  and subscribe, we can call dispatch. And dispatch is a method which dispatches an action.

  Refer redux-demo.js

************************************************* More redux basics *****************************************************
. We are dispatching an action here and that action has a type of increment. Typically when using Redux, the goal is to 
  do different things inside of the reducer for different actions. And that's why you get the action as a second 
  argument here. You get the current state and then the action that was dispatched that caused this reducer to run.
  And therefore in the reducer, we can of course, look into this action.

  Refer counterReducer()

************************************************* Prepaing a new Project ***********************************************
. Now to make working with Redux in React applications easier. There is a second package apart from redux which we 
  should install the react-redux package. This is a package which makes connecting react applications to Redux stores 
  and reducers ends on very simple. It will, for example, make it very simple to subscribe components to the Redux store.
  So you should install these two packages into this React project.

************************************************* Creating a redux store for react ************************************
. Refer store/index.js
. Now previously, we did now subscribe here and dispatch from inside this file and that's now not what we wanna do here.
  Instead now, I wanna connect my React app to this Redux store. So that the components of that app can dispatch and 
  listen. 
  
  And now I want to connect my React application to that store. For this, we need to provide this store to the 
  React app. And since, remember, we only have one Redux store, we only need to provide our store once, the only store 
  we have. The question just is, what does provide mean?

************************************************* Providing the store **************************************************
. To provide our Redux store to the React app, we typically go into this index.js file, where we rendered the entire app.
  So to the highest level we can go, in our react application, to the top of our component tree, where we render this 
  root component. And now here, we can import from react Redux. So not from Redux, but from react-redux. And what we 
  import here, is now the Provider component. This is actually a component. And now we wrap, all our root component, 
  with provider, a little bit, as we used our own context provider components.

. you don't have to use provider on this highest component level. You could also wrap nested components with provider,
  but only wrapped components and their child components, and the child components of the child components, and so on.
  Only those components will have access to Redux thereafter. And if the vast majority of your components need access
  to the store, if maybe your entire app, needs access to the store, you should typically provide, on this highest level.

. Now just by wrapping Provider around App, we're now telling react-redux and react therefore, which store we wanna   
  provide. Sure. We only have one store, but that's stored in this index JS file, react Redux of course doesn't know
  that data file holds our store. Instead we have to import our store from, store index in this case. So that store,
  which we're exporting in there, we're importing this into index JS, and on this provider, which we import from react 
  Redux. We have a store prop, which we have to set. And this one's a value, a value which is our Redux store.

  Now our components in this app, the app component, and any other child components, can tap into that store. They can 
  get data out of the store. They can set up a subscription to that data to be precise, and they also can dispatch 
  actions.

  Refer root/index.js

************************************** Using Redux data in react components: useSelector() *****************************
. Now here I wanna start by outputting the current counter. And for this we need to get access to our Redux store and to 
  the data in there. And we again do that with help of the React Redux Library. So from React Redux we again wanna 
  import something and the something which we are importing is a React Hook. A custom hook made by the React Redux team.
  The useSelector hook. There also is useStore hook, which we could use as well which gives us direct access to the 
  store but you as selector is a bit more convenient to use because that allows us to then automatically select a part
  of our state managed by the store.

. So here in this functional component we can now get access to the data managed in our store by using useSelector.
  We call this and now we need to pass a function to useSelector(). A function which will be executed by a React Redux
  of function which then basically determines which piece of data we wanna extract from our store. Of course at the 
  moment we have a very simple state. Just an object with a counter property. But in bigger applications, you will have 
  more complex states with tons of different properties maybe nested objects and arrays and therefore being able to just 
  get a slice just a tiny part of that overall state object in a easy way is worth a lot. And that's what useSelector 
  allows us to do. For this we should pass a function to it, a function of which we'll receive the state managed by 
  Redux and then we return the part of the state which you wanna extract.

. So we get a counter constant which is the counter managed by Redux. Now the great thing is that when you use use 
  selector, React Redux will automatically set up a subscription to the Redux store for this component. So your 
  component will be updated and will receive the latest counter automatically whenever that data changes in the Redux 
  store.

  If you ever would unmount this component if it would be removed from the DOM for whatever reason, React Redux would 
  also automatically clear the subscription for you. So it manages that subscription for you behind the scenes.

  Refer component/Counter.js

******************************************** Dispatching actions from inside components ********************************
. Now we know that we need to dispatch an action before that. But how does that work from inside a react component?
  Well, there is another hook which we can use, the useDispatch hook. When we call use dispatch here, we don't pass any 
  argument to it, but instead, this gives us back a dispatch function which you can execute. So dispatch here is a 
  function, a function which we can call, which will dispatch an action against our Redux store.
  Refer component/Counter.js

******************************************** Redux with Class-based components *****************************************
. how do we get access to Redux here? In the functional component we used hooks - useDispatch() and useSelector(), but 
  hooks are not usable in class-based components. Now, I briefly did mention it before, react Redux also exports a 
  connect function, which is a function that helps you connect class-based components to Redux Actually, you could also 
  use it on functional components, but for functional components, using these hooks is simply more convenient.

. How do we use it? When we export our counter, we don't export the counter component like this. Instead we call connect 
  and now connect when executed, will actually return a new function as a value, which we then execute again. And then 
  we pass our component to that returned function as our argument. So this can look strange, but connect is a so-called 
  higher order component. We execute the connect function. It then returns a new function, and we execute this returned, 
  this new function as well. And to this returned function, we pass counter.

. The first function is a function that maps Redux state to props, which will be received in this component then. Now, 
  this is a function which receives the Redux state, and then this returns an object where the keys will be available
  as props in the receiving component.

  The second argument is another function, which is typically called map dispatch to props. It's the equivalent to use 
  dispatch. Now the idea is to store dispatch functions in props. So that in the counter component, we have certain props
  which we can execute as a function, which will then when executed dispatch an action to the Redux store.

  Refer component/Counter.js

******************************************** Attaching payloads to actions *******************************************
. Up to this point, we only dispatched simple actions. They only had a type, nothing else. In reality, you often wanna 
  dispatch actions that also carry an extra value. Let's say we wanna add a new button to the counter component, which 
  says increase by 5. We could, of course also had a decreased button but let's stick to the increase button for now.

  Now, even though it has this label it of course only increases this by one because I still just call the 
  incrementHandler here and dispatch increment. Of course, we could now go to the store and prepare our Reducer for 
  another action type which is increaseby5.

  But that's not scalable. We can't predict all possible values we might wanna support. The counter of course is just a 
  dummy example. But if you're using this in a real project, which we'll do later in the course, and you need to work 
  with any user input, for example, you can't hard-code those values here in your Reducer. Instead, the action which we 
  dispatch and which reaches the Reducer often needs to carry extra data.

  Refer component/Counter.js

******************************************* Working with multiple state properties **************************************
. we always just worked with our single counter value. Now I got this Toggle Counter button here and when it's clicked,
  I wanna make sure that the counter is hidden and when it's clicked again, it should be shown again. Now for this, of 
  course, we could use useState. So we could set up some local state in this component which we manage with useState, 
  not with Redux. And that would be the proper way of doing it because showing or hiding the counter is something which 
  only is interesting to this component, not to any other part of the application but the same could be set about our 
  counter. We are only using the counter in this component here. So the counter technically also is local state but this 
  is just a simple demo to get started.

. So when we click this button, the toggleCounterHandler is fired. And then here we wanna dispatch an action which 
  changes some state in Redux which controls whether this counter div is shown or not. For this, we need to add a new 
  state a new piece of data to our Redux store. And how do we now do that?

  Well, to add a new piece of data, we need to go to our reducer in the end and just add it to all these state snapshots 
  which we are producing.

  Refer component/Counter.js and store/index.js

******************************************* How to work with Redux state correctly **************************************
. Now let's talk about the objects which we are returning in our reducer, in our Redux reducer. I mentioned in the last 
  lecture that we always return a brand new snapshot, a brand new state object which Redux will use to replace its 
  existing state with. So the objects which we return in the reducer will not, and that's super important will not be 
  merged with the existing state. They will overwrite the existing state.

  So if we, for example going to set showCounter here when we incremented because before it got to add it here, if we do
  this if I click increment, you see I close my counter. I closed my counter when I click increment even though I 
  shouldn't, because I don't set show counter here hence it's basically removed from the object and it has a value of 
  undefined therefore an undefined is treated as false. So we don't render to counter then. And that's of course a 
  side-effect, which we don't want. That's an error. 
  
  So we must always set all the other states when we update a piece of state because we overwrite the old state. 
  Whenever you need to update data you never just dive into an existing object and start manipulating its properties.
  Always copy and create new objects.

******************************************* Redux challenges & Introducing Redux toolkit *******************************
. Before we do that though, let's identify a couple of potential problems we could be facing here if our application 
  would continue to grow. So if we manage more and more state with Redux. 
  
  One potential issue can be our action types. These identifiers, I mentioned it before, you of course have to avoid 
  typos. If you dispatch an action, you have to make sure that you don't mistype the identifier here otherwise it of 
  course won't be handled by the reducer or won't be handled correctly. So therefore having some way of defining those 
  identifiers once and then reusing them would be nice.

  Another potential problem is the amount of data which we manage here. The more data we have the more different pieces
  of state we have, the bigger our state objects get. And that means that we need to copy a lot of state when we update 
  the counter we still need to copy and keep all the other state properties, and it also means that this reducer 
  function gets longer and longer and all of a sudden we might have an unmaintainable big Redux file. And you might 
  recall that I brought this up as one potential disadvantage of React Context. If we put everything into one context 
  provider file. Now we can end up with the same problem with the Redux but thankfully there are solutions for that with
  Redux.

  Another potential problem we could be facing is the state immutability which we have to respect. I talked about it in 
  the last lecture. We have to ensure that we always return a brand new state snapshot and that we don't accidentally 
  change the existing state anywhere. And especially if you have more complex data with nested objects and arrays it's 
  easy to mess this up and accidentally change some nested data even though you didn't want to. So it would be great if 
  we would have some help with that as well. And if we could ensure that we don't accidentally manipulate nested data or 
  anything like that.

  Now for all those problems there are solutions we could implement on our own. For example, for ensuring that we have 
  unique identifiers and we don't miss type we could create constants, let's say a constant named increments which 
  stores this identifier, and we then export this constant and we check that constants value here and we then import
  and use that constant in the counter component so that here we use the type increment and we just import increments.
  That is something we could do to fix this issue. And these are approaches which we typically used in the past with 
  Redux. const INCREMENT = 'increment';

  There also are solutions for splitting your reducer into multiple smaller reducers so that you don't get this large 
  super big file, and there also our solutions and third-party packages which allow you to automatically copy state
  and ensure that you don't accidentally edit it. But we actually don't need to dive into those various solutions 
  anymore.

  Instead there is another library called Redux Toolkit. It's actually developed by the same person or the same team as 
  React Redux and Redux itself and Redux Toolkit simply as an extra package which makes working with Redux more 
  convenient and easier.

****************************************************** Adding state slices *********************************************
. npm install @reduxjs/toolkit
. Now, when you install that you then there after can also uninstall Redux. So the Redux library itself because that is 
  already included in Redux toolkit. So you could now remove this Redux entry here from package Json.

. Here at the top and the index.js file we can import something from @reduxjs/toolkit. Add that's something is the 
  createSlice() function. There also is a createReducer function which would also allow us to create a reducer with 
  certain enhancements, but creatSlice is even more powerful than createReducer. And it will simplify a couple of 
  aspects in one go.

. Now, what we do with createSlice is we are preparing a slice of our global state. And when we have different pieces of 
  state which are not directly related, let's say an authentication status and the counter status, we could create 
  different slices potentially also in different files to make our code maintainable.

. Now every slice needs a name and identifier of that piece of state so to say. And here I'll name this counter but the 
  name is up to you. It doesn't have to be this name here, it can be any name you want. Next you need to set up an 
  initialState. And here I wanna set my initial state equal to that object or I therefore just point at initialstate

  And then we also need to add reducers. Reducers is again, an object, a map you could say, of all the reducers this 
  slice needs, this state slice needs. Now here in this object, you can now simply add methods with any names of your 
  choice, though those names will become important later. And here I'll add an increment method. I will add a decrement 
  method. I will add an increase method, and I will also add my toggleCounter method, let's say. So for methods because 
  I had four different if cases in my reducer before.

  Now, every method here will then automatically receive the latest state. These methods will be called for you by Redux,
  and they will receive the current state.  Also to the action, and we'll use that in a second, but actually here we 
  don't need the action because these methods will automatically be called for you depending on which action was 
  triggered.

. Now in these methods here in the reducers map we now also can do something else than we did before. Now, here we are 
  allowed to mutate the state. So here we can set state.counter++ for example, for incrementing it. Now this was 
  forbidden before and I emphasized that it is forbidden. I also did emphasize it because here it seems to be allowed.
  But the important part is the word seems. We still must not manipulate the existing state but the good thing is when 
  using Redux toolkit and its functions like createSlice, we can't accidentally manipulate the existing state.

  Because Redux toolkit internally uses another package,  called imgur, which will detect code like this and which will 
  automatically clone the existing state, create a new state object, keep all the state which we're not editing, and 
  override the state which we are editing in an immutable way. So we still have immutable code here even though it 
  doesn't look like it because of this internally used package and therefore we as a developer have a much easier time 
  working with Redux because we don't have to create a copy manually and keep all the code we're not changing, instead, 
  we just change the code we wanna change and internally it's translated into immutable code.

. So now we created this slice and writing that code is certainly quite convenient and shorter than what we had to do 
  down there. But how do we now make our store aware of that slice? How do we use that slice? And how do we then 
  dispatch actions against this slice?

*************************************************** Connecting Redux toolkit State *************************************
. Now to use our slice, we first of all need to use the return value of calling createSlice because here we get back
  our counterSlice.

. Now we just couldn't dispatch actions right now, but in theory, we would be good to go like this. But if we have 
  bigger applications with multiple state slices, we would face a problem if we try to do it like this, because there 
  can only be one reducer passed to createStore and when we have multiple slices, we have multiple reducers which we 
  access with .reducer on the different slices.

  Now with standard Redux, there is a combineReducers() function which we could use for that but we can also ditch Redux 
  here and instead import another function from reduxjs/toolkit which will make that a bit easier. ConfigureStore like 
  createStore creates a store but it makes merging multiple reducers into one reducer easier thereafter. and to 
  configureStore, we now pass an object not a reducer function but an object. It's a configuration object expected by 
  configureStore. A configuration object where we then set a reducer property and that's an expected property by 
  configureStore. Reducer singular and not reducers plural because still, no matter if we use createStore or 
  configureStore, Redux wants one main reducer function, which is responsible for the global state.

  However, with configureStore, the value for reducer can be a single reducer so we can for example use counterSlice.
  reducer to use the reducer from that counterSlice which combines all those reducer methods to find in that slice. We 
  can use that as a global main reducer and here that would make sense because this is the only state slice we have
  and therefore, the only reducer we have, but if we had multiple state slices in a bigger application something we're 
  going to see later, then alternatively as a value for this reducer key, we could also set an object and in that object,
  we can set up any keys of our choice, so any property names of our choice and the values of those properties would 
  then be different reducer functions. So we would create a map of reducers you could say, and this map is then set as a 
  value for the main reducer and behind the scenes configureStore will emerge all those reducers into one big reducer.

. Now the question is, how do we dispatch actions? Because we don't have our own, if checks, we don't know what the 
  identifiers for our actions should be. We just have these method names but how do we now know what to dispatch?

************************************************* Migrating everything to redux toolkit ********************************
. Now for dispatching actions, createSlice has got us covered. It automatically creates unique action identifiers for 
  our different reducers. To get hold of these action identifiers, we can use our counterSlice and access dot actions.
  That is then an object full of keys, where the the key names, increment, decrement, and so on. Match the method names 
  we have in our createSlice function in the reducers area.

  Now we can access those keys on this actions object. And with that we don't access the reducer methods to find up 
  there but instead we get methods created automatically by Redux Toolkit which when called will create action objects 
  for us. These methods on the actions object here which we can call will create action objects for us. Therefore these 
  methods are called action creators and they will create action objects for us where these objects already have a type 
  property with a unique identifier per action. Automatically created behind the scenes.

  So that means that what we could do here is at the bottom of this file, we get our counter actions like this. And we 
  then for example, export our counter actions. So we don't just export the store but also our counter actions. And by 
  doing this we can then go to the component where we need the actions in this case to counter JS file, and import from 
  our index JS file here, and import the counter actions which we just exported there.

  So now if we want to dispatch an action here all we have to do is we have to access counter actions. And then for 
  example, here, increment and actually execute this as a method because increment is a method which when executed 
  creates a full action object with the type set to this automatically created unique action identifier. So we get a 
  full action object automatically created for us here.

. The question just is what do we do here when we also need a payload? And the answer is we still use our account or 
  actions and then use this automatically generated action creator method here. But then to this method, we pass our 
  payload data. So for example, an object with any property value pairs of our choice or just the number by which we 
  want to increase here. So any kind of value can be passed to increase. The only important thing to know here is how
  you then extract that value because what Redux Toolkit will do for us here is it will automatically create action 
  objects which dispatches where the type is some unique identifier generated by Redux toolkit and any value you pass 
  here. As an argument to this action method you're executing, will it be stored in an extra field named payload. And 
  that field name is not up to you. That's the default Redux Toolkit uses here.

  But now with help of Redux Toolkit and this was certainly a bit of work to translate our code to refactor our code, to 
  use Redux Toolkit. But now that we did transform our code, it's shorter, it's more concise and it's easier to maintain.
  And it's also easier to now work with Redux.  If you have a more complex application which we don't have yet but which 
  we will still get in this course.

  Refer Counter.js

************************************************* Working with multiple slices *****************************************
. Now, in this starting project, which I provided to you, we got a couple of other components as well, not just a 
  Counter. We get a couple of other components as well because there's more I wanna practice and teach you when it comes 
  to Redux. And therefore, it's now time to use some of these other components. In the App.js file, in this App 
  component, we will add Header and Auth component, Refer App.js

. Well, here I would like to make this login form work. I wanna make sure that when we click Login, we do switch into 
  some login mode and for example, what we see here in the navigation bar changes. These items and the logout button
  should only be displayed if we are logged in in Redux and I also wanna swap this login field here, this login form for 
  another component, the UserProfile component which has some dummy output. 
  
  So we have a brand new state to manage. And unlike the counter state, which was just a basic example, the 
  authentication state and the answer to the question whether the user is logged in or not is indeed not just local 
  state, which matters to one specific component but it is application-wide state, which matters to a lot of components 
  in the application. It matters to the Header, it matters to the Auth component, it matters to the UserProfile 
  component in the end. So therefore, this is the user authenticated state is a perfect example for a state that we 
  could manage with React context or since this section is about Redux, with Redux.

  I wanna make sure that when we click the Login button, we set the user to authenticated. If we click the Logout button,
  I wanna set the user to not authenticated. And for this, in our store here, we can add a brand new state, a brand new 
  piece of data.

. Now, the question is where we should add our authentication data. We do have this slice, which we created here, this 
  counter slice and in there, we manage the counter and the showCounter state. We could, of course, also add a new 
  property to our state here. Let's say the isAuthenticated property and set this to false and then add a new reducer, 
  login, for example, a new reducer method, and in here, we then set is isAuthenticated to true. We could do this but 
  logically it makes no sense. The authentication status has nothing to do with the counter. Whilst it would technically
  work, in programming we typically wanna separate our concerns. We wanna make sure that this slice really focuses
  on the counter-related state and actions. And we should create a brand new slice for the authentication state.
  Refer : store/index.js

. Now, very important, when you work with multiple slices, you still only have one Redux store, so you still only call 
  configureStore once. This does not change. And this store only has one root reducer here but as I briefly explained 
  earlier, this reducer actually does not just take a reducer function as an argument but also an object which acts as a 
  map of reducers where you can then have any key names of your choice, for example, counter and then point at your 
  different reducers. Here, for example, add counterSlice.reduce. And then we also add auth let's say as a key
  and then here we add authSlice.reducer. And these individual reducers here will then automatically be merged together
  into one main reducer, which is exposed to this store. That's how we can combine multiple slices and their reducers.
  eg:
      const store = configureStore({
        reducer: {
          counter: counterSlice.reducer,
          auth: authSlice.reducer,
        },
      });

****************************************** Reading & Dispatching from a new slice ***************************************
. In App component and render the Auth component, if we're not authenticated and render UserProfile if we are 
  authenticated. we need to tap into our store and read a value from there.
  Refer App.js for getting value from store 
  Refer Header.js form dispatching action(logout button) and Auth.js for login

************************************************* Splitting our code ****************************************************
. I wanna split up this index.js file into store folder. It's actually quite a small file not too much code in it, but 
  of course, in your typical a React application where you have multiple state slices, this can become a very long file.
  
  So therefore it might be worth splitting it up into smaller pieces. And when using Redux Toolkit it could make sense 
  to put every slice into its own file. So we could add a new file in the store folder and let's say the counter-slice.
  JS file or just counter.JS, the file name is up to you. And then we want to create and manage the counter specific 
  state and slice in there, and same for Auth.

************************************************* Summary ***************************************************************
. Redux is an amazing library. It can replace React context as you learned but it's also not a must use library. It's 
  always up to you to decide whether for your project you want to go with React context, or if you need Redux. React 
  context can have certain disadvantages as I mentioned, but they might not matter in your project. You might not see or 
  measure any performance issues and you might not have a super complex setup and management. Then of course, there's 
  nothing wrong with sticking to React context, because you must not forget that if you use Redux, you do add an extra 
  third party library. And that of course adds up to the overall code of your application. It makes your application 
  bigger. So Redux is not always better. It can be a decent option.