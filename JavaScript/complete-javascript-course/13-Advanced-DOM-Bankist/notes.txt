*************************************************** How the DOM really works ******************************************
. DOM is basically the interface between all JavaScript code and the browser, or more specifically HTML documents
  that are rendered in and by the browser.

  Now in the DOM there are different types of nodes. For example some nodes are HTML elements but others are just text, 
  remember? And this is really important to understand because all these DOM methods and properties are organized into 
  these different types of objects.

. Every single node in the DOM tree is of the type, Node. and such as everything else in JavaScript, each node is 
  represented in JavaScript by an object. This object gets access to special node methods and properties, such as text 
  content, child nodes, parent nodes, clone nodes and many others.

  Now we already know that there are different types of nodes. Right? So how should these be represented?
  
  Well, this node type has a couple of child types so to say. And these are the element type, the text type, the comment
  type and also the document type. So whenever there is text inside any element, we already know that it gets its own node.
  Right? And that node will be of the type, text. And the same actually happens for HTML comments and that's because the 
  rule is that everything that's in the HTML has to go into the DOM as well.

  Now for the element itself there is the element type of node. And this type of node gives each HTML access to a ton of 
  useful properties such as innerHTML, classList, children or parent element. There are also many useful methods like 
  append, remove, insertAdjacentHTML, querySelector, closest and that's just to name a few. So again, each element will be
  represented internally as an object.

  Now just to make this complete, the element type has internally an HTML element, child type. And that element type 
  itself has exactly one child type for each HTML element that exists in HTML. So we have a special type for buttons,
  a special type for images, for links, and so on and so forth. And that's important because each of these HTML elements
  can have different unique properties. For example and image has a source attribute in HTML which no other element has.
  Or the anchor element for links has the HREF attribute which also no other element has. And so the DOM needs a way of 
  storing these different attributes and therefore different types of HTML elements were created in the DOM API.

. Now comes the really important part, because what makes all of this work is something called inheritance. So what is 
  inheritance? Well inheritance means that all the child types will also get access to the methods and properties of all 
  their parent node types. For example an HTML element will get access to everything from the element type, like innerHTML,
  or classList or all these other methods and properties.

  And besides that it will also get access to everything from the Node type because that is also its parent type. So we 
  can think of this as though the HTML button element for example, is also an element and also a node.

. Document Node Type: So document, which we use all the time in DOM manipulation is in fact just another type of node so 
  it contains important methods, such as querySelector, createElement and getElementById. And note how querySelector is 
  available on both the document and element types.

. And remember we usually listen for events by calling the addEventListener method on an element or the document. Right?
  So why does that actually work? Well its because there is a special node type called EventTarget which is a parent of 
  both the node type and also the window node type. And so with this, thanks to inheritance, we can call addEventListener
  on every single type of node in the DOM API because all elements as well as document and window, and even text and 
  comment will inherit this method and therefore we will be able to use addEventListener on all of them just as if it was
  their own method.

  Now just to be clear, we do never manually create an eventTarget object. This is just an abstract type that we do not 
  use in practice. This all really happens behind the scenes to make all the functionality work as we expect it to work.

**************************************************** Types of Events and Event Handlers *******************************
. An event is basically a signal that is generated by a certain dom node and a signal means that something has happened, 
  for example, a click somewhere or the mouse moving, or the user triggering the full screen mode and really anything of 
  importance, that happens on our webpage, generates an event.
  
  And as we already know, we can then list and fold these events in our code using EventListeners so that we can then 
  handle them if we'd like.

. There is one on-event property for each event, but this way of listening to events is a bit old school. Now we usually 
  use addEventListener.
  
  there are two ways why addEventListener is better -
  the first one is that it allows us to add multiple event listeners to the same event.
  the second one even more important is that we can actually remove an event handler in case we don't need it anymore.
  We need to use named funtion for this

*************************************** Event Propagation : Capturing and Bubbling ************************************
. JavaScript events have a very important property. They have a so-called capturing phase and a bubbling phase. So here we
  have a very simple HTML document(See pdf) along with a dom tree, but only for the anchor element that's represented in 
  red here. let's now say that a click happens on the link and the dom then generates a click event right away. However, 
  this event is actually not generated at the target element. Instead, the event is actually generated at the root of the
  document, so at the very top of the dom tree. And from there, the so-called capturing phase happens, where the event 
  then travels all the way down from the document route to the target element. And as the event travels down the tree, it
  will pass through every single parent element of the target element.

  So in our example, here, the HTML element, the body element, the section, then the paragraph, until it finally
  reaches its target. As soon as the event reaches the target, the target phase begins, where events can be handled right
  at the target. So event listeners wait for a certain event to happen on a certain element, and as soon as the event 
  occurs, it runs the attached callback function. and this happens in the target phase.

  Now, after reaching the target, the event then actually travels all the way up to the document route again, in the 
  so-called bubbling phase. So we say that events bubble up from the target to the document route. And just like in the 
  capturing phase, the event passes through all its parent elements, and really just the parents, so not through any 
  sibling elements. So as an event travels down and up the tree, they pass through all the parent elements, but not through
  any sibling element.

. But now you might be wondering why is this so important? Why are we learning about all this detail? Well, it is indeed
  very important because basically, it's as if the event also happened in each of the parent elements. So again, as the 
  event bubbles through a parent element, it's as if the event had happened right in that every element. 
  
  What this means is that if we attach the same event listener, also for example, to the section element, then we would 
  get the exact same alert window for the section element as well. So we would have handled the exact same event twice, 
  once at its target, and once at one of its parent elements. And this behavior will allow us to implement really powerful
  patterns.

. Now by default, events can only be handled in the target, and in the bubbling phase. However, we can set up event 
  listeners in a way that they listen to events in the capturing phase instead. Also, actually not all types of events 
  that do have a capturing and bubbling phase. Some of them are created right on the target element, and so we can only 
  handle them there. But really, most of the events do capture and bubble. We can also say that events propagate, which is
  really what capturing and bubbling is. It's events propagating from one place to another.

**************************************************** Lifecycle DOM events ********************************************
. DOMContentLoaded: this event is fired by the document as soon as the HTML is completely parsed, which means that the
  HTML has been downloaded and been converted to the DOM tree. Also, all scripts must be downloaded and executed
  before the DOMContentLoaded event can happen.

  Now this event does actually not wait for images and other external resources to load. So just HTML and JavaScript need
  to be loaded.

  In fact, we want all our code only to be executed after the DOM is ready. Right? So does that mean that we should wrap 
  our entire code into an event listener like this? So with a function like this, well, actually, no, we don't need to do
  that. And that's because we have to script tag, which is the one that imports or a JavaScript into the HTML, right. At 
  the end of the body. So you see it is down here. So basically it's the last thing that is going to be read in the HTML.

  And so basically the browser will only find our script when the rest of the HTML is already parsed anyway. So when we 
  have to script tag here at the end of the HTML, then we do not need to listen for the DOM content loaded event.

  When we have script tag at the end of the HTML, then we do not need to listen for the DOMContentLoaded event.

. load: next up there is also the load event and the load event is fired by the window. As soon as not only the HTML is 
  parsed, but also all the images and external resources like CSS files are also loaded. So basically when the complete 
  page has finished loading is when this event gets fired.
  
. beforeunload: this event here is created immediately before a user is about to leave a page. So for example, after
  clicking this close button here in the browser tab, so we can basically use this event to ask users if they are 100% 
  sure that they want to leave the page.

  Now in some browsers to make this work, we need to call preventDefault() here. In Chrome it's not necessary, but some
  browsers require it. this event should be handled in a situation in which data could actually be lost by accident.

. Refer script.js for examples

**************************************************** Efficient Script Loading: defer and async *************************
. Up to this point, we have always used the regular way of including JavaScript files into our HTML. However, we can also 
  add the async attribute to the script tag like this, or the defer attribute. And these attributes are gonna influence 
  the way in which the JavaScript file is fetched, which basically means download and then executed.

. Now in the HTML, we can write the script tag in the document head, or usually at the end of the body. So these are the 
  two situations that we're gonna be comparing in this slide.

  So when we include a script without any attribute in the head, what will the page loading process look like over time?
  Well, as the user loads the page and receives the HTML, the HTML code will start to be parsed by the browser and parsing
  the HTML is basically building the DOM tree from the HTML elements. Then at a certain point, it will find or a script 
  tag, start to fetch the script, and then execute it.

  Now, during all this time, the HTML parsing will actually stop. So it will be waiting for the script to get fetched and
  executed. Only after that, the rest of the HTML can be parsed. And at the end of that parsing, the DOMContentLoaded 
  event will finally get fired.
  
  Now, this is not ideal at all, right? We don't want the browser to be just sitting there doing nothing, because this can
  have a huge impact on the pages performance. Plus, in this case, the script will actually be executed before the DOM is
  ready. And so again, that's not ideal. So never do this, never include the script in the head like this.

  That's why we usually always put the script tag at the end of the body, so that all the HTML is already parsed, when it
  finally reaches the script tag. So in this situation, this is how the page loading process looks like. The HTML is 
  parsed, then the script tag is found at the end of the document, then the script is fetched. And then finally, the 
  script gets executed. And this is much better.

. async attribute: Well, this is what the loading process looks like when we use async script loading in the head of the 
  document. So as you can see, the difference is that the script is loaded at the same time as the HTML is parsed. So in 
  an asynchronous way, so that's already an advantage. However, the HTML parsing still stops for the script execution.
  So the script is actually downloaded asynchronously. But then it's executed right away in a synchronous way.

  And so the HTML code has to wait for being parsed. But anyway, as we can see from the length of the diagrams, this still
  makes page loading time shorter.

. defer attribute: Well, when deferring what happens is that the script is still loaded asynchronously. But the execution
  of the script is deferred until the end of the HTML parsing. So in practice, loading time is similar to the async 
  attribute, but with the key difference that would defer the HTML parsing is never interrupted, because the script is only
  executed at the end. And many times, this is exactly what we want.

. Refer pdf notes