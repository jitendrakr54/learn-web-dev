************************************************** Default Parameters *************************************************
. one thing that's really cool about the default values is that they can contain any expression.

. We can skip parameter by passing undefined, and this works because setting the parameter to undefined is seame thing 
  as not even setting it.

. Refer script.js

****************************************** How passing arguments works: value vs reference ****************************
. Passing a primitive type to a function is really just the same as creating a copy like this, outside of the function.
  So the value is simply copied.
  
  On the other hand, when we pass an object to a function, it is really just like copying an object like this. And so 
  whatever we change in a copy will also happen in the original.

  Now, of course, we need to be careful with this behavior and always keep it in mind. That's because the fact that 
  objects behave this way when passed to functions can have unforeseeable consequences in large code bases.

. In programming, there are two terms that are used all the time when dealing with functions, which is passing by 
  value, and passing by reference. JavaScript does not have passing by reference, only passing by value, even though it 
  looks like it's passing by reference. for objects, we do in fact pass in a reference. So the memory address of the 
  object.
  
  However, that reference itself is still a value. It's simply a value that contains a memory address. So basically we 
  pass a reference to the function, but we do not pass by reference, and this is an important distinction.

. Refer script.js

****************************************** First-class and Higher-order functions ************************************
. See pdf notes

. JavaScript is a language that has first class functions which in technical terms means that functions are so-called 
  first citizens. In practice, that means that functions are simply treated as values.

  why does JavaScript treat function as values?
   
  Well, it's simply because functions are really just another type of objects in JavaScript. And since objects are 
  values, functions are values too. And since functions are values, there is a bunch of interesting things that we can 
  do with them, like storing them in variables or object properties. We can also pass functions as arguments to other 
  functions. For example, we passed function in event listener.

  Finally, remember that functions are objects. And many types of objects in JavaScript have methods. Like array 
  methods, for example. And actually there are also function methods -  call(), apply(), bind() So methods that we can 
  call on functions.

. Now the fact that JavaScript has first-class functions makes it possible for us to use and write higher order 
  function. So a higher order function is either a function that receives another function as an argument, or a 
  function that returns a new function.

  the addEventListener function is the higher order function. And why?

  Well, because it receives another function as an input. And we usually say that the function that is passed in is a 
  callback function. That's because the callback function will be called later by the higher order function.

. First class functions is just a feature that a programming language either has or does not have. All it means is that 
  all functions are values. That's it. There are no first class functions in practice, okay? It's just a concept.

  There are however higher order functions in practice, which are possible because the language supports first class 
  functions. So it's a subtle difference. A function that receives another function as an argument, that returns a new 
  function, or both. This is only possible because of first-class functions.

****************************************** Function accepting callback functions *************************************
. Functions even have methods remember, and besides methods, functions can even have properties. And one of them is the 
  name property.

. Why our callback functions so much used in JavaScript and why are they so helpful? 

  Well, the first big advantage of this is that it makes it easy to split up or code into more reusable and 
  interconnected parts.

  But there is a second and way more important advantage, which is the fact that callback functions allow us to create 
  abstraction. Abstraction is something really important in programming. So basically what abstract and means, is that 
  we hide the detail of some code implementation because we don't really care about all that detail. And this allows us 
  to think about problems at a higher more abstract level. And so that's why it's called an abstraction.
  
  In example, the transformer a function does not care at all, how the string is transformed. It doesn't care about this
  level of detail. Okay, all that wants to do is to transform a string, but it doesn't care how it should do it. And now
  with this idea of abstraction and higher levels and lower levels of abstraction, here is called a higher order 
  function. and again that's basically because this function here operates at a higher level of abstraction, leaving the 
  low level details to this low level functions.

  For example, the addEventListener function on its own would have no idea of what to do whenever the click event 
  happens here. And so that's why we pass in the callback function here, to tell the add event listener function exactly 
  what to do. And as you already know, this is the higher order function here with the high level of abstraction. And 
  this here is the function with, the more lower level of abstraction.

. Refer script.js

*********************************************** Functions returning functions ****************************************
. Refer script.js

*********************************************** The call and apply methods *******************************************
. The call() method calls the function with a given this value and arguments provided individually.

  Normally, when calling a function, the value of this inside the function is the object that the function was accessed 
  on. With call(), you can assign an arbitrary value as this when calling an existing function, without first attaching 
  the function to the object as a property. This allows you to use methods of one object as generic utility functions.

  So call() allows us to manually and explicitly set the this keyword of any function that we want to call.

. apply method does basically exactly the same thing. The only difference is that apply does not receive a list of 
  arguments, but instead, it's gonna take an array of the arguments

  apply method is not that used anymore in modern JavaScript because now, we actually have a better way of doing
  the exact same thing - spread operator in call() method.

*********************************************** The bind method *****************************************************
. bind() just like the call method, bind also allows us to manually set this keywords for any function call. Now, the 
  difference is that bind does not immediately call the function. Instead it returns a new function where this keyword 
  is bound. So it's set to whatever value we pass into bind.

. bind() could be useful with event listener because here, function we pass doesn't get called immidiately and that's 
  what bind() does.

. Partial Application:
  Many times we are not even interested in this keywords, but we still use bind for this. Now, remember that partial 
  application means that we can preset parameters.

  But in this case, we don't care about the this keyword at all. It's not even here in the function. And so, we just 
  say, null. It could be any other value because nothing will happen with it, but it's kind of a standard to just use 
  null.

  So bind() can be used to preset some parameter.

*********************************************** Immediately invoked function expression (IIFE) ************************
. Sometimes in JavaScript, we need a function that is only executed once. And then never again. So basically a function
  that disappears right after it's called once.

. Why was this pattern actually invented?
  we already know that functions create scopes. And what's important here is that one scope does not have access to 
  variables from an inner scope. For example, right here in this global scope. We do not have access to any variables 
  that are defined in the scope of any of these functions here. for example if we add a variable inside above function 
  that won't be accessible from outer scope. 
  
  Therefore, we say that all data defined inside a scope is private. We also say that this data is encapsulated. and this
  is a way of creating data privacy which means encapslation.

  And that scopes are a good tool for doing this. And this is also the reason why The Immediately Invoked Function
  Expressions were invented. So this is not really a feature, of the JavaScript language. It's more of a pattern, that 
  some developers came up with. And that then started to being used, by many other developers.

  But creating a scope can be done by adding variable in a block using let and const, so that's the reason why now in
  modern JS, Immediately Invoked Function Expressions are not used anymore. Because if all we want to create a new
  scope or data privacy, so all we just create a block {}. There's no need to creating a function to create a new scope.

  Now on the other hand, if what you really need, is to execute a function just once, then the IIFE. So the Immediately 
  Invoked Function Expression pattern is still the way to go even now with modern JavaScript.

**************************************************** Closure *********************************************************
. Refer pdf notes

. A closure is not a feature that we explicitly use. So we don't create closures manually, like we create a new array
  or a new function. So a closure simply happens automatically in certain situations, we just need to recognize those
  situations.

  A closure makes a function remember all the variables that existed at the function's birthplace essentially. So we 
  can imagine the secureBooking as being the birthplace of this booker function. So booker always remember passengerCount
  from secureBooking(). We can check it using console.dir(booker)

. Any function always has access to the variable environment of the execution context in which the function was created.
  Now, in the case of Booker, It was born in the execution context of secure booking, which was popped off the stack
  previously.

  So, therefore the Booker function will get access to this variable environment, which contains the passengerCount.
  variable. and this is how the function will be able to read and manipulate the passengerCount variable.

  A function always has access to the variable environment of the execution context in which it was created, even after 
  that execution context is gone. The closure is then basically this variable environment attached to the function, 
  exactly as it was at the time and place that the function was created.

  The scope chain is actually preserved through the closure, even when a scope has already been destroyed because its 
  execution context is gone.

. the Booker function has access to the passengerCount variable because it's basically defined in the scope in which 
  the Booker function was actually created. So in a sense, the scope chain is actually preserved through the closure, 
  even when a scope has already been destroyed. because its execution context is gone.

  This means that even though the execution context has actually been destroyed, the variable environment somehow
  keeps living somewhere in the engine. Now we can say that the Booker function closed over its parents scope or over 
  its parent variable environment. and this includes all function arguments. Even though in this example, we don't have 
  any. and now this attached or closed over variable environment stays with the function forever. It will carry it around
  and be able to use it forever.

  To make it a bit more digestible, we can also say that thanks to the closure, a function does not lose connection
  to variables that existed at the function's birthplace.

. let's see what happens now with execution of the Booker function. So the function attempts to increase the
  passengerCount variable. However, this variable is not in the current scope. And so JavaScript will immediately
  look into the closure and see if it can find the variable there. And it does this even before looking at the scope
  chain.
  For example, if there was a global passengerCount variable set to 10, it would still first use the one in the
  closure. So the closure basically has priority over the scope chain. And so after running this function, the
  passengerCount becomes one. This message is logged. And then the execution context is popped off the stack.

  Then execution moves to the next line(new booker call). We get a new execution context and a closure is still there,
  still attached to the function and the value is still one. And so now this function executes, increasing the
  passengerCount to two and logging a message again.

. There is no way for us to explicitly access closed over variables. That's because closures are not like a tangible
  thing. They're not like an object or so that we can access. So we cannot just reach into a closure
  and take variables from it. That's impossible because a closure is just an internal property of a function.
  We can observe that a closure happens because functions magically keep having access to variables that should no
  longer exist, but we cannot directly access these variables.
  
  However, what we can do is to actually take a look at this internal property.

. A closure is the combination of a function together with it's lexical environment.

**************************************************** More Closure examples *******************************************
. Refer script.js

. We don't need to return if function from another function in order to create a closure.

**************************************************** Function currying ************************************************
. Currying in JavaScript transforms a function with multiple arguments into a nested series of functions, each taking a 
  single argument. Currying helps you avoid passing the same variable multiple times, and it helps you create a higher 
  order function.

  . Using Closure:

    function sum(a, b, c) {
      return a + b + c;
    }
    sum(1,2,3); // 6

    function sum(a) {
      return (b) => {
          return (c) => {
              return a + b + c
          }
      }
    }
    console.log(sum(1)(2)(3)) // 6

    const multiply = function(a, b) {
      return function(b) {
        return a*b;
      }
    }
    const multiplyBytwo = multiply(2);
    multiplyBytwo(3);
    const multiplyBytwo = multiply(5);
    multiplyBytwo(3);

  . Using bind():

    const multiply = function(a, b) {
      return a*b;
    }

    const multiplyBytwo = multiply.bind(null, 2);
    multiplyBytwo(3);
    const multiplyBytwo = multiply.bind(null, 5);
    multiplyBytwo(3);

