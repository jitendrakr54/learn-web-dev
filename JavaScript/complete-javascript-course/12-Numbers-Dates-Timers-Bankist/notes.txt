************************************************** Converting and Checking numbers *************************************
. In JavaScript, all numbers are represented internally as floating point numbers. So basically, always as decimals, no 
  matter if we actually write them as integers or as decimals.
  
  Numbers are represented internally in a 64 base 2 format. So that means that numbers are always stored in a binary 
  format. So basically, they're only composed of zeros and ones.

  Now, in this binary form, it is very hard to represent some fractions that are very easy to represent in the base
  10 system that we are used to.

  Base 10 - 0 to 9. 1/10 = 0.1, 3/10 = 3.3333333
  Base 2 -  0,1

. We converts into numbers using Number() method or + operator, because when JavaScript sees the plus operator, it will 
  do type coercion.

. Methods:
      Number(), +
      Number.parseInt(), Number.parseFloat()
      Number.isNan()
      Number.isFinite()
      Number.isInteger()

// ************************************************** Math and Rounding **********************************************
. Methods:
      Math.sqrt(), Math.max(), Math.min(), Math.random(), Math.trunc(), Math.round(), Math.ceil(), Math.floor(), toFixed

//************************************************** Remainder operator % **********************************************
. Well, as the name says, the remainder operator, simply returns the remainder of a division.

************************************************** Numeric separator: 2021 ********************************************
. Let's say that we wanted to represent a really large number. For example, the diameter of our solar system. Let's say a
  diameter, which is 287460000000. And just from looking at this number here, it's really difficult to read and to 
  understand it. Does this mean like 28 billion or is it just 2 billion or really what is this number? It's really hard to
  read like this. There is just too many zeros here.

  Now to help with this, when we write a number this large under normal English language, we usually use a thousand 
  separator like the comma. We would write this number like this. And then it becomes really easy to immediately see that
  this means 287,460,000,000.

. And now, fortunately, we can do the same thing in JavaScript as well, using the new numeric separators. Numeric 
  separators are simply underscores that we can place anywhere that we want in or numbers, and which will make it really 
  easy to understand and to parse numbers this large. Using the underscore here as a thousand separator, then makes it 
  really easy to understand, that this number here means in fact, 287 billion.

  We can only put separator between numbers. below is incorrect, gives Error
  const PI = 3._1415;

  If you need to store a number in a string, for example, in an API, or if you get a number as a string from an API,
  you should not use underscores in there, because then JavaScript will not be able to parse the number correctly out of
  that string.

***************************************************** BigInt *********************************************************
. Numbers are represented internally as 64 bits. and that means that there are exactly 64 ones or zeros to represent
  any given number. Now of these 64 bits only 53 are used to actually store the digits themselves. The rest are for 
  storing the position of the decimal point and the sign. 
  
  Now, if there are only 53 bits to store the number, that means that there is a limit of how big numbers can be, and we
  can calculate that number. So that's two elevated to 53 and then minus one, because the numbers starts at zero. and so 
  that is this gigantic number right here. And so this is essentially the biggest number that JavaScript can safely 
  represent.

  console.og(2**53-1)

  And so if we do calculations with numbers that are bigger than this, then we might lose precision.

. So, this can be a problem sometimes because in some situations we might need really, really big numbers. Way bigger than
  this one here, for example, for database IDs or when interacting with real 60 bit numbers and these numbers are actually
  used in other languages. And so we might, for example from some API, get a number that is larger than this. And then we
  have no way of storing that in JavaScript, at least not until now, because now starting from IES 2020 a new primitive 
  was added, which is called BigInt.

  BigInt stands for big integer. And it can be used to store numbers as large as we want. So no matter how big. and to 
  represent big number, We can append n to the large number or we can use BigInt()

. Now we can not mix BigInt with regular numbers while doing operation.

***************************************************** Creating Dates ***************************************************
. There are four ways to create dates in JavaScript.
  Using default constructor, Using string, By passing date in formate, By passing number of milliseconds 

******************************************************* Operations with Dates ******************************************
Refer script.js

******************************************************* Internaionalizing Dates ***************************************
. JavaScript has a new Internationalization API. Now that sounds very fancy, but all it does is to allow us to easily 
  format numbers and strings according to different languages. So with this new API, we can make our applications support
  different languages for users around the world which is pretty important.

  For example, currencies or dates are represented in a completely different way in Europe or in the U.S or in Asia for 
  example. Now there is a lot of language specific things that we can do with the Internationalization API.

. Refer Bankist Project

******************************************************* Internaionalizing Numbers ***************************************
. Refer script.js

***************************************************** Timers: setTimeout() and setInterval() ***************************
. we have two kinds of timers - 
  First, the setTimeout() timer runs just once, after a defined time, while the setInterval() timer keeps running basically
  forever, until we stop it. So basically, we can use set timeout to execute some code at some point in the future.

. Code execution does not stop here at this point, so when the execution of our code reaches this point,
  it will simply call the setTimeout function, it will then essentially register this callback function here to be
  called later. And then the code execution simply continues. this mechanism is called Asynchronous in JavaScript.

***************************************************** Implementing countdown timer *************************************
. Refer Bankist app